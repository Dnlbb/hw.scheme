(define (my-range a b d)
  (define (my-range-helper a b d lst)
    (cond ((>= a b) (reverse lst))
          ((< a b) (my-range-helper (+ d a) b d (cons a lst)))))
  (my-range-helper a b d '()))
;;O((b-a)/d)
(define (my-flatten list)
  (cond
    ((null? list) '())          
    ((not (pair? (car list)))  (cons (car list) (my-flatten (cdr list))))
    (else (append (my-flatten (car list)) (my-flatten (cdr list))))))
;;O(n^2)

(define (my-element? x xs)
  (cond ((null? xs) #f)
        ((equal? (car xs) x) #t)   
        (else (my-element? x (cdr xs)))))
;;O(n)


(define (my-filter pred? xs)
  (define (my-filter-helper pred? xs lst)
    (cond ((null? xs) (reverse lst))
          ((pred? (car xs))  (my-filter-helper pred? (cdr xs) (cons (car xs) lst)))
          (else (my-filter-helper pred? (cdr xs) lst))))
  (my-filter-helper pred? xs '()))
;;O(n)
 
(define (my-fold-left op xs)
  (define (my-fold-left-helper op xs temp)
    (cond ((= 1 (length xs)) temp)
          (else (my-fold-left-helper op (cdr xs) (op temp (cadr xs))))))
  (my-fold-left-helper op xs (car xs)))
;;O(n^2)
(define (my-fold-right op xs)
  (define (my-fold-right-helper op xs temp)
    (cond ((= 1 (length xs)) temp)
          (else (my-fold-right-helper op (cdr xs) (op (cadr xs) temp)))))
  (my-fold-right-helper op (reverse xs) (car (reverse xs))))
;;O(n^2)
